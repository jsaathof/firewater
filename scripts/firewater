#! /usr/bin/env python3
#
#   firewater.py    WJ111
#
#   firewater by Walter de Jong <walter@heiho.net> (c) 2012
#
#   firewater COMES WITH NO WARRANTY. firewater IS FREE SOFTWARE.
#   firewater is distributed under terms described in the GNU General Public
#   License.
#

'''firewater is a tool for managing your host-based firewall'''

import os
import sys
import getopt
import errno
import socket

from typing import List

import firewater
import firewater.globals
import firewater.parser
import firewater.bytecode

from firewater.lib import debug


def generate() -> None:
    '''loads plugin module and generates the rules'''

    # insert default 'chain: incoming' rule
    rule = firewater.bytecode.ByteCode()
    rule.set_chain('', 0, 'incoming')
    firewater.globals.BYTECODE.insert(0, rule)

    # insert comment: generated with firewater
    comment = firewater.bytecode.ByteCode()
    comment.set_comment('', 0, f'generated by firewater {firewater.globals.VERSION}')
    firewater.globals.BYTECODE.insert(0, comment)

    # load appropriate module
    module = __import__('firewater.' + firewater.globals.MODULE)
    module = getattr(module, firewater.globals.MODULE)

    # generate rules from bytecode
    module.begin()

    while True:
        if not firewater.globals.BYTECODE:
            break

        bytecode = firewater.globals.BYTECODE.pop(0)
        if bytecode is None:
            break

        assert bytecode.type is not None
        debug(f'bytecode: {firewater.bytecode.ByteCode.TYPES[bytecode.type]}')

        if bytecode.type == firewater.bytecode.ByteCode.TYPE_RULE:
            module.generate_rule(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_POLICY:
            module.generate_policy(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_CHAIN:
            module.change_chain(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_ECHO:
            module.generate_echo(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_VERBATIM:
            module.generate_verbatim(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_COMMENT:
            if firewater.globals.VERBOSE:
                module.generate_comment(bytecode)

        elif bytecode.type == firewater.bytecode.ByteCode.TYPE_EXIT:
            debug(f'exiting with exit code {bytecode.exit_code}')
            sys.exit(bytecode.exit_code)

        else:
            raise RuntimeError(f'invalid bytecode type {bytecode.type}')

    module.end()


def usage() -> None:
    '''display usage information'''

    print('usage: {} [options] <input file> [..]'.format(os.path.basename(sys.argv[0])))
    print('''options:
  -h, --help                  Display this information
  -v, --verbose               Verbose output
  -D, --define=DEFINE         Define a symbol
      --debug                 Enable debug mode
      --version               Print version number and exit

The syntax of the input lines is described in the documentation
''')
    print('firewater {} by Walter de Jong <walter@heiho.net> (c) 2012'.format(firewater.globals.VERSION))


def get_options() -> List[str]:
    '''parse command line options'''

    if len(sys.argv) <= 1:
        usage()
        sys.exit(1)

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'h?vD:',
                                   ['help', 'verbose', 'define=', 'debug', 'version'])
    except getopt.error as reason:
        print('{}: {}'.format(os.path.basename(sys.argv[0]), reason))
#       usage()
        sys.exit(1)

    for opt, arg in opts:
        if opt in ('-h', '--help', '-?'):
            usage()
            sys.exit(1)

        if opt in ('-v', '--verbose'):
            firewater.globals.VERBOSE = True
            debug('verbose mode')
            continue

        if opt in ('-D', '--define'):
            if arg not in firewater.globals.DEFINES:
                firewater.globals.DEFINES.append(arg)
            continue

        if opt == '--debug':
            firewater.globals.DEBUG = True
            debug('debug mode')
            continue

        if opt == '--version':
            print(firewater.globals.VERSION)
            sys.exit(0)

    # remaining arguments are filenames for input
    return args


def main() -> None:
    '''run the program'''

    input_files = get_options()

    # define the name of the current output module as a 'DEFINE'
    if firewater.globals.MODULE not in firewater.globals.DEFINES:
        firewater.globals.DEFINES.insert(0, firewater.globals.MODULE)

    # add the fqdn of the machine to the defines
    try:
        fqdn = socket.getfqdn()
    except (socket.error, socket.herror, socket.gaierror):
        pass
    else:
        fqdn_def = fqdn.replace('.', '_').upper()
        if fqdn_def not in firewater.globals.DEFINES:
            firewater.globals.DEFINES.append(fqdn_def)

    if firewater.globals.DEBUG:
        # show what defines we have
        for symbol in firewater.globals.DEFINES:
            debug(f'external define: {symbol}')

    # read input: the rule set
    errors = 0

    if not input_files:
        errors = firewater.parser.read_input_file('/dev/stdin')
    else:
        for filename in input_files:
            errors = firewater.parser.read_input_file(filename)

    if errors:
        sys.exit(1)

    # generate output: the translated rules
    generate()

    sys.exit(0)


if __name__ == '__main__':
    try:
        main()
    except OSError as err_:
        if err_.errno == errno.EPIPE:      # Broken pipe
            pass
        else:
            print(err_)
            sys.exit(127)

    except KeyboardInterrupt:       # user pressed Ctrl-C
        sys.exit(127)

    except RuntimeError as err_:
        print(f'error: {err_}')
        sys.exit(1)

# EOB
